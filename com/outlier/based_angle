import numpy as np
from com.sort.AlgorithmSort import computeKnn2, postiveAngNum, sortBubble2, dataLoad, splitData, angleVar
from matplotlib import pyplot as plt
import math
from sklearn.cluster import DBSCAN
'''
0.获取数据
'''
# dataSet = dataLoad('../../data/t7_10k_16/data7')
dataSet = dataLoad('../../data/t7_10k_4/data0')
'''
1.设置参数
'''
n = len(dataSet)
minPts = math.floor(5*math.log10(n))
c = math.floor(n*0.02)
print(minPts)
# minPts = 30
dataSetEdge, knnMatrix = computeKnn2(minPts+c, dataSet)
dist_cutoff = np.mean(np.array(knnMatrix)[:, c+1, 1]) # sortBubble2(dataSetEdge[2], 'ascend')[c]

'''
2.求密度
'''
pi_block = []
for i in range(0, n):
    pi = 0
    for j in range(0, n):
        if dataSetEdge[i][j] < dist_cutoff:
            pi += 1
    pi_block.append(pi)

'''
3.求角度ksi
'''
v_block = []
t_block = []
ksi_block = []
for i in range(0, n):
    knn = knnMatrix[i]
    normalVec = []
    for j in range(0, minPts):
        x_ji = np.subtract(dataSet[i], dataSet[knn[j][0]])/knn[j][1]
        normalVec.append(x_ji)
    vi = angleVar(minPts, normalVec)
    v_block.append(vi)
    ti = postiveAngNum(minPts, normalVec)
    t_block.append(ti)

v_max = max(v_block)
for i in range(0, n):
    vi = v_block[i]/v_max
    ksi = vi/t_block[i]
    ksi_block.append(ksi)

ksi_max = max(ksi_block)
for i in range(0, n):
    ksi_block[i] = ksi_block[i]/ksi_max

'''
4.求r
'''
r = 10
if np.mean(pi_block) < 10:
    r = 5

'''
5. 求结果边界点
'''
outliers = []
for i in range(0, n):
    if pi_block[i]/r < min(np.mean(pi_block)/r, max(ksi_block)):
        outliers.append(dataSet[i])
outliers = np.array(outliers)
'''
6.画出结果
'''
if len(outliers):
    plt.scatter(dataSet[:, 0], dataSet[:, 1], s=5, c='g', marker='*')
    plt.scatter(outliers[:, 0], outliers[:, 1], s=5, c='r', marker='*')
plt.show()